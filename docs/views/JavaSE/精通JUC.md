---
title: 精通JUC并发十八版武艺
date: 2020-05-12
sidebar: 'auto'
categories:
 - JavaSE
tags:
 - 多线程
publish: true
---

## 第1章 开宗明义【告诉你：学什么+收获什么】

  相信很多小伙伴学习过悟空第一门并发基础课，是不是觉得不过瘾？因此我们盛情邀请实力人气新生代讲师：悟空大佬二度出山，带你深入并发，带你并发领域升级打怪，本章告诉你本课程学什么，你将收获什么~期待小伙伴在并发领域：百尺竿头，更进一步~~...

### 1-1 Java并发成神之路——精通JUC并发工具十八般武艺**试看**



  ## 第2章 鸟瞰Java并发【上帝视角建立并发知识框架】

  要想达到线程安全，有多种方法，本章将从如何解决线程安全问题说起，引出可以解决安全问题的3大类手段，并逐一详细展开。

### 2-1 并发工具类纵览——建立起Java并发体系的大厦**试看**
### 2-2 课程各章节思维导图汇总



  ## 第3章 线程池【治理线程的最大法宝】

  线程池是非常重要的工具，如果你要成为一个好的工程师，还是得比较好地掌握这个知识，很多线上问题都是因为没有用好线程池导致的。即使你为了谋生，也要知道，这基本上是面试必问的题目，而且面试官很容易从被面试者的回答中捕捉到被面试者的技术水平。...

### 3-1 线程池的自我介绍
### 3-2 增减线程的时机
### 3-3 keepAliveTime和线程工厂
### 3-4 演示内存溢出的情况
### 3-5 线程池用法演示
### 3-6 对比线程池的特点
### 3-7 五虎上将收服线程池
### 3-8 钩子：给线程池加点料
### 3-9 Executor家族的辨析
### 3-10 线程池状态和使用注意点



  ## 第4章 ThreadLocal【一次解决老大难问题】

  ThreadLocal是面试常客，同时也是工作中非常常用的工具，可以给我们开发提供很多便利。本章将对它做出详细解读。

### 4-1 ThreadLocal的两种用法**试看**
### 4-2 进化之路：故事从两个线程说起
### 4-3 进化之路：线程池来帮忙，却好心办坏事
### 4-4 走过的弯路，你的套路
### 4-5 ThreadLocal是救火队长
### 4-6 悔不当初：回顾进化之路
### 4-7 ThreadLocal的第二种用法 part1
### 4-8 ThreadLocal的第二种用法 part2
### 4-9 ThreadLocal的两种用法总结
### 4-10 ThreadLocal的好处
### 4-11 ThreadLocal原理
### 4-12 ThreadLocal的重要方法介绍
### 4-13 重要方法的源码分析
### 4-14 两种场景，殊途同归
### 4-15 收不回来的value
### 4-16 ThreadLocal的空指针异常问题
### 4-17 ThreadLocal在Spring中的应用



  ## 第5章 不可不说的“锁”事【种类繁多，如何一一突破？】

  各种类型的锁很多，包括悲观锁、乐观锁、共享锁、公平锁、可重入锁、自旋锁等等，乱花渐欲迷人眼，如何拨开迷雾，看透本质？

### 5-1 本章纵览
### 5-2 内置锁的能力不足以满足需求
### 5-3 tryLock尝试获取锁
### 5-4 代码演示：获取锁时被中断
### 5-5 锁的可见性保证
### 5-6 互斥同步锁
### 5-7 非互斥同步锁
### 5-8 可重入锁的用法
### 5-9 可重入性质和源码解析
### 5-10 是否允许一部分人“先富起来”
### 5-11 代码演示：先来后到的特例、优劣、源码分析
### 5-12 共享锁和排它锁的用法
### 5-13 深入理解交互思想
### 5-14 看似读锁按部就班
### 5-15 超越95%面试者的秘籍 part 1
### 5-16 超越95%面试者的秘籍 part 2
### 5-17 读写锁的由奢入俭“易”
### 5-18 循环尝试，不释放CPU
### 5-19 可中断锁
### 5-20 我们如何才能让锁变得更好用？
### 5-21 “锁”事总结



  ## 第6章 atomic包【一刻也不能分割】

  对于原子包的6个类型做出用法和原理的讲解

### 6-1 什么是原子类，有什么作用？
### 6-2 6类原子类纵览
### 6-3 AtomicInteger案例演示
### 6-4 Atomic数组，每个都安全
### 6-5 Atomic引用在自旋锁的应用
### 6-6 把普通变量升级为原子变量
### 6-7 对比新旧工具的运行速度
### 6-8 剖析高速运转的原理
### 6-9 功能升级，不限于加操作
### 6-10 总结原子类



  ## 第7章 CAS【不可中断的典范】

  非互斥同步的灵魂——CAS，对于这个不易理解的概念，给出通俗易懂的解读

### 7-1 什么是CAS
### 7-2 CAS的等价代码、使用案例
### 7-3 CAS的应用场景、源码分析
### 7-4 CAS的缺点和总结



  ## 第8章 以不变应万变【最便捷的并发安全之道】

  介绍不变性和final关键字带来的线程安全

### 8-1 什么是“不变性”？
### 8-2 final变量的赋值时机
### 8-3 final的注意点
### 8-4 栈封闭技术
### 8-5 面试题：真假美猴王



  ## 第9章 ConcurrentHashMap等并发集合【面试超高频考点】

  精讲最常见的并发容器，包括ConcurrentHashMap、CopyOnWriteArrayList、各种阻塞队列，从用法到内部结构，面面俱到。

### 9-1 并发容器概览
### 9-2 集合类的历史，演进过程：Vector和Hashtable
### 9-3 前身：同步的HashMap和ArrayList
### 9-4 ConcurrentHashMap概览
### 9-5 Map接口的典型实现类、常用方法演示
### 9-6 彩蛋：调整JDK版本，以便查看对应版本的代码
### 9-7 HashMap的死循环导致CPU100%的问题分析
### 9-8 彩蛋：多线程调试技巧，每个线程独立调试
### 9-9 HashMap的死循环分析
### 9-10 HashMap 1.7和1.8的结构图和特点，红黑树的概念
### 9-11 ConcurrentHashMap 1.7和1.8结构图
### 9-12 ConcurrentHashMap源码分析-
### 9-13 ConcurrentHashMap1.7和1.8的对比，做了哪些升级？
### 9-14 ConcurrentHashMap难道也会发生线程安全问题？：组合操作的玄机
### 9-15 实际生产中并发安全事故的分享、ConcurrentHashMap复习
### 9-16 CopyOnWriteArrayList的适用场景、读写规则
### 9-17 CopyOnWrite设计理念、数据过期问题
### 9-18 CopyOnWrite源码、缺点分析
### 9-19 并发队列简介
### 9-20 彩蛋：轻松绘制漂亮的UML图
### 9-21 BlockingQueue入门
### 9-22 ArrayBlockingQueue代码演示、源码分析
### 9-23 LinkedBlockingQueue等典型介绍
### 9-24 并发容器总结



  ## 第10章 控制并发流程【做好线程之间的协调人】

  控制并发流程的工具类，作用就是帮助我们程序员更容易得让线程之间合作，让线程之间相互配合，来满足业务逻辑，比如让线程A等待线程B执行完毕后再执行等合作策略。

### 10-1 如何控制并发流程？
### 10-2 倒计时门闩，一等多
### 10-3 综合用法：运动员跑步
### 10-4 Semaphore颁发许可证
### 10-5 Semaphore用法和注意点
### 10-6 条件对象的作用和用法演示
### 10-7 用条件对象实现生产者模式
### 10-8 循环栅栏的作用
### 10-9 总结控制并发流程的要点



  ## 第11章 AQS【进阶必备，并发灵魂人物】

  AQS是众多并发工具底层的核心原理，掌握了它，你就打通了任督二脉，登上了并发大雅之堂。

### 11-1 如何学习AQS？
### 11-2 Semaphore和AQS的关系
### 11-3 比喻：HR和AQS的职责统一
### 11-4 AQS的三要素
### 11-5 AQS源码分析
### 11-6 AQS的许可证颁发
### 11-7 利用AQS实现独占锁
### 11-8 DIY一次性门闩
### 11-9 AQS的核心思路
### 11-10 AQS补充材料（选修）



  ## 第12章 获取子线程的执行结果【来而不往非礼也】

  Future的核心思想是：一个方法的计算过程可能非常耗时，一直在原地等待方法返回，显然不明智。可以把该计算过程放到线程池去执行，并通过Future去控制方法的计算过程，在计算出结果后直接获取该结果。

### 12-1 Future和Callable的关系
### 12-2 代码演示：submit返回Future对象，快速抽取返回值
### 12-3 批量接收结果
### 12-4 执行时异常和isDone演示
### 12-5 代码演示：默认广告的超时和取消
### 12-6 cancel方法与中断线程
### 12-7 用法二：用FutureTask获取结果
### 12-8 总结Future本章



  ## 第13章 从0到1打造高性能缓存【学以致用，直击痛点】

  理论结合实际，知识落地。把学到的知识运用在实际中，从0开始一步步搭建高性能缓存。

### 13-1 从最简单的缓存出发
### 13-2 暴露出来的性能和复用性问题
### 13-3 用装饰者模式解耦
### 13-4 用ConcurrentHashMap保证并发安全
### 13-5 用Future解决重复计算问题
### 13-6 原子组合操作填补漏洞
### 13-7 计算错误如何处理？
### 13-8 缓存“污染”问题的解决
### 13-9 缓存过期功能和随机性
### 13-10 用线程池测试缓存性能
### 13-11 用CountDownLatch实现压测
### 13-12 用ThreadLocal确认时间的统一性
### 13-13 打怪升级之路总结



  ## 第14章 结语【总结全课精华】

  全课精华总结，展望未来学习路径

### 14-1 全课精华总结 part 1
### 14-2 全课精华总结 part 2



  ## 第15章 【试看】学习本课程有困难？ 

  学习本课程有困难？不妨加持线程部分。特别开放试看章节~

### 15-1 Java并发核心知识体系精讲课程介绍 
### 15-2 核心1：实现多线程的方法是1种还是2种还是4种？-网上的观点和正确的观点 
### 15-3 同时使用两种方法；正确实现方法的总结 
### 15-4 典型错误观点 
### 15-5 彩蛋-优质学习路径 
### 15-6 彩蛋-如何了解技术前沿；如何在业务缠身的情况下让技术快速成长 
### 15-7 实现多线程-2个常见面试问题 