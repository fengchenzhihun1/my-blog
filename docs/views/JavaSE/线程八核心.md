---
title: 线程八大核心
date: 2020-05-06
sidebar: 'auto'
categories:
 - JavaSE
tags:
 - 多线程
publish: true
---

## 第1章 开宗明义【不看错过一个亿】

  本章一连串设问：为什么学并发编程？学并发编程痛点？谁适合学习本课？本课程包含内容和亮点？首先4大个理由告诉你为什么要学，其实源于JD岗位要求就不得不服了。其次5个痛点+12个亮点，是否说服你要死磕Java并发编程呢？...



  ###  1-1 Java并发成神之路——线程8大基础和Java内存模型**试看**

* 线程八大核心
* java内存模型
* 死锁的前世今生

## 第2章 跨越第一座山“线程八大核心”【适用于纵观全貌】

  八大核心-序章。从本章开始将带你攻克并发编程领域的“第一座大山”：多线程八大核心。

###  2-1 纵观全貌——线程八大核心

* 实现线程的方法
* 启动线程的正确和错误方法
* 停止线程的正确方法
* 线程的6个状态
* Thread和Object类中和线程相关的重要方法
* 线程各属性
* 线程的未捕获异常UncaughtException应该如何处理
* 线程是把双刃剑

###  2-2 抛砖引玉——初识八大基础

1. 实现多线程的方法到底有1中还是2种还是4种？
2. 怎样才是正确的线程启动方式？
3. 上山容易下山难-如何正确停止线程？（难点）
4. 线程的一生-6个状态（生命周期）
5. Thread和Object类中的重要方法详解
6. 线程的各个属性
7. 未捕获异常如何处理
8. 双刃剑：多线程会导致的问题

###  2-3 思维导图地址汇总

[面试题](https://docs.qq.com/doc/DSVNyZ2FNWWFkeFpO)

[线程八大核心](https://naotu.baidu.com/file/07f437ff6bc3fa7939e171b00f133e17?token=6744a1c6ca6860a0)

[java内存模型](https://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9?token=bcdbae34bb3b0533)

[死锁--从产生到消除](http://naotu.baidu.com/file/ec7748c253f4fc9d88ac1cc1e47814f3?token=bb71b5895a747d67)

[思维导图面试必考](http://naotu.baidu.com/file/29942292cd032adfae23c09783676004?token=130df3d389cab703)

[并发工具分类](http://naotu.baidu.com/file/3902a010470d7c1cf76fe719be124797?token=bec25)

## 第3章 核心1：实现多线程的正确姿势【解读官方文档，够权威】

  相信很多小伙伴经常在各大技术博客或者论坛甚至面试中、工作中迷茫于线程到底有几种实现方式。真如网络所说实现线程有N种方式么？本章节利用【官方文档】现身说法，足够权威，让你即使面对面试官也能从容不迫。

###  3-1 迷雾重重——究竟如何创建新线程？

![image-20200507003454879](C:\Users\wrcsh\AppData\Roaming\Typora\typora-user-images\image-20200507003454879.png)

**方法一**

```java
package com.chenfeng.thread2.createthreadmenthod;
/**
 * @Classname RunnableStyle
 * @Description 创建线程的方式实现runnable接口
 * @Date 2020/5/7 0:39
 * @Created by  wrsChen
 */

public  class RunnableStyle implements Runnable{
    public static void main(String[] args) {
        Thread thread = new Thread(new RunnableStyle());
        thread.start();
    }
    @Override
    public void run() {
        System.out.println("使用runnable方式创建线程");
    }
}

```

**方法二**

```java
package com.chenfeng.thread2.createthreadmenthod;

/**
 * @Classname ThreadStyle
 * @Description TODO
 * @Date 2020/5/7 0:43
 * @Created by  wrsChen
 */
public class ThreadStyle extends Thread{


    public static void main(String[] args) {
        Thread thread = new Thread(new ThreadStyle());
        thread.start();
    }
    @Override
    public void run() {
        System.out.println("threadf方式");
    }

}

```

方法1实现（实现Runnable）更好

* 从代码架构角度：具体的任务（run方法）应该和“创建和运行线程的机制（Thread类）”解耦，用runnable对象可以实现解耦。

* 使用继承Thread的方式的话，那么每次想新建一个任务，只能新建一个独立的线程，而这样做的损耗会比较大（比如重头开始创建一个线程、执行完毕以后再销毁等。如果线程的实际工作内容，也就是run()函数里只是简单的打印一行文字的话，那么可能线程的实际工作内容还不如损耗来的大）。如果使用Runnable和线程池，就可以大大减小这样的损耗。

* 继承Thread类以后，由于Java语言不支持双继承，这样就无法再继承其他的类，限制了可扩展性。

**两种方法的对比**

* 方法一：最终调用(target=Runnable)target.run()
* 方法二：run()整个被重写

###  3-2 无独有偶——同时使用两种方法；正确实现方法的总结

###  3-3 偏信则暗——典型错误观点
###  3-4 授人以渔——彩蛋：【优质学习路径】
###  3-5 日新月异——彩蛋：【如何了解技术前沿动态？】
###  3-6 奋发蹈厉——彩蛋：【如何在业务缠身的情况下让技术快速成长？】
###  3-7 眼前一亮——实现多线程常见面试问题

## 第4章 核心2：开启多线程启动的世界

  本章借着案例深入剖析start()和run()方法原理，最后以面试问题检验小伙伴学习成果，巩固本章知识。

###  4-1 初出茅庐——启动线程的正确姿势
###  4-2 起承转合——start()方法原理解读
###  4-3 中流砥柱——run()方法原理解读
###  4-4 天缘凑合——彩蛋：【Java名字由来的奇闻轶事】
###  4-5 启动线程——常见面试问题

## 第5章 核心3：线程停止、中断之最佳实践【填“坑”式教学，从错误到正确】

  牢记线程停止原则，做优秀的线程掌门人。线程停止、中断，从错误到正确的最佳实践之路，带你从错误中总结真理。本章首先设“坑”，以错误方式停止或是中断线程，再回归正道。

###  5-1 偃旗息鼓——让线程停下来
###  5-2 奉公守法——牢记线程启停原则，做优秀的线程掌控者
###  5-3 普通情况——停止线程的最佳实践
###  5-4 遭遇阻塞——当停止线程遇到线程阻塞，怎么办？
###  5-5 大跌眼镜——这是bug吗？自动清除中断信号
###  5-6 最佳实践——中断线程的两种姿势之优先抛出
###  5-7 官复原职——中断线程的两种姿势之恢复中断
###  5-8 耳听八方——网罗响应线程中断的N种方法
###  5-9 不速之客——彩蛋：【Java异常体系】
###  5-10 戛然而止——错误的停止线程方法之一-模拟军队发放武器
###  5-11 看似可行——错误的停止线程方法之二-外置属性
###  5-12 跌跌跄跄——失效导致永久等待【路走错了，莫慌，回头是岸】
###  5-13 直击本质——彩蛋：【分析native层代码——以interrupt为例】
###  5-14 明辨是非——练习：判断interrupt状态的方法辨析
###  5-15 停止线程——常见面试问题

## 第6章 核心4：图解线程生命周期【适用于面试】
 一图胜千言，面试亮出此图“线程生命周期图”，优秀的候选人非你莫属。本章详解线程的6种状态、转化路径、触发条件，同时配备完善的案例演示，最后通过面试问题检验你的学习成果，助你轻松掌握内容。

###  6-1 纵观天下——线程的生命周期
###  6-2 一图千言——状态的含义和变化
###  6-3 眼见为实——演示前3种状态：NEW、RUNNABLE、TERMINATED
###  6-4 眼见为实——演示后3种状态：BLOCKED、WAITING、TIMED_WAITING
###  6-5 生命周期——状态转换的注意点、阻塞的定义、面试问题

## 第7章 核心5：趣解Thread和Object类中线程相关方法【只学有用的】

  Thread类和Object类中，有很多和线程息息相关的重要方法，包含wait(), notify(), notifyAll(), sleep(), join(), yield(), Thread.currentThread()等，本章对这些重要方法进行详解，从用法到面试，面面俱到。

###  7-1 中流砥柱——7个重要方法概览
###  7-2 你方唱罢——wait的作用和用法
###  7-3 我方登场——notify与notifyAll的区别
###  7-4 忠心耿耿——wait只释放当前monitor
###  7-5 一针见血——wait/notify的原理、特点
###  7-6 生产消费——用wait/notify实现
###  7-7 你来我往——两个线程交替打印0~100的奇偶数
###  7-8 面试问题——wait相关高频面试题
###  7-9 熟悉陌生——彩蛋：Java相关概念辨析，JDK、JRE、JVM、Java SE
###  7-10 各持己见——sleep方法概览、不释放锁
###  7-11 阳春白雪——sleep响应中断、优雅写法、一句话总结、面试问题
###  7-12 拭目以待——join的作用和普通用法
###  7-13 望穿秋水——join遇到中断、join期间线程状态的两种查看方式
###  7-14 孪生兄弟——join注意点、原理、源码分析、替代写法、面试问题
###  7-15 孔融让梨——yield的作用、定位、和sleep的区别、currentThread举例

## 第8章 核心6：一网打尽线程属性

  线程属性三大经典面试问题，你晓得么？本章介绍线程的4个最重要的属性：守护线程和普通线程最大的区别是什么？为什么不应该利用线程优先级设计程序？

###  8-1 庖丁解牛——线程重要属性概览
###  8-2 对号入座——线程ID，线程的唯一身份标识
###  8-3 守护天使——线程名字、守护线程
###  8-4 上上之选——线程优先级、4个属性总结、线程属性面试问题

##第9章 核心7：线程异常处理知多少？

  无处不在的异常，只需一招自定义异常，即可御敌于千里之外。线程中的异常和我们平时的异常有很大区别，对线程内异常的处理也大有讲究。本章带你深入浅出“未捕获异常UncaughtException”。

###  9-1 居安思危——需要UncaughtException的3个理由
###  9-2 层层递进——异常处理器的调用策略
###  9-3 线程异常——自己实现并处理异常；常见面试问题

##第10章 核心8：追寻并发的崇高理想-线程安全【日常开发工作常用】

  线程安全与程序性能看似无法平衡的两个“死对头”，取舍之道怎么拿捏？做到“线程安全”是并发编程的最高境界和理想，但是理想丰满现实骨感，一不小心就会掉入并发安全的“陷阱”。本章将让小伙伴清晰拿捏取舍之道。

###  10-1 崇高理想——并发安全总起
###  10-2 线程安全——权威定义和通俗易懂的解读
###  10-3 神出鬼没——结果错误，a++会让加的次数莫名消失
###  10-4 不断进击——a++具体在哪里消失？又消失了几个呢？（上）
###  10-5 不断进击——a++具体在哪里消失？又消失了几个呢？（下）
###  10-6 互不相让——死锁发生
###  10-7 逃出生天——逸出private对象的后果
###  10-8 你中有我——this赋值
###  10-9 心急火燎——隐藏的风险：注册监听器
###  10-10 时不我待——构造函数中新建线程
###  10-11 狸猫太子——用“副本”代替“真身”
###  10-12 工厂模式——解决逸出的妙用
###  10-13 面面俱到——预警编程时容易踩坑的地方
###  10-14 伤敌一千——上下文切换、内存同步
###  10-15 自损八千——双刃剑总结

## 第11章 多线程的八大核心【最终回】

  在此，先预祝小伙伴们即将翻越并发的第一座大山“多线程八大核心”，本章将通过思维导图总结线程八大核心技能图谱，让小伙伴们巩固并升华前面所学知识。

###  11-1 对答如流——八大核心面试问题总结
###  11-2 全面总结——八大核心重点回顾
###  11-3 思维导图——八大核心梳理，资料下载地址

## 第12章 深入浅出并发编程底层原理-上篇

  Java内存模型是并发底层原理，是进阶必备。掌握Java内存模型，才能代表你学懂了并发编程。本章是知其所以然的章节，层层递进，深入原理，把重排序、可见性、原子性这三个JMM最重要的内容用多个代码形象地演示出来，理论结合实际，让小伙伴轻松掌握底层原理。最后引出面试高频考点和总结。...

###  12-1 纵观全貌——本章思维导图概览
###  12-2 自顶向下——彩蛋：【自顶向下学习方法的好处】
###  12-3 刨根问底——什么是“底层原理”？为什么要研究“底层原理”？
###  12-4 兄弟齐心——JVM内存结构、Java内存模型、Java对象模型
###  12-5 难分伯仲——JMM是什么？重排序、可见性、原子性简介
###  12-6 眼见为实——重排序的前3种可能性
###  12-7 意料之外——真正发生重排序
###  12-8 化零为整——重排序的好处和3种发生时机、重排序总结
###  12-9 一叶障目——概述可见性
###  12-10 只见树木——演示可见性问题
###  12-11 不见森林——为什么会有可见性问题？
###  12-12 化繁为简——JMM的抽象
###  12-13 瞻前顾后——如何利用规则保证“可见”
###  12-14 逐一列出——happens-before有哪些规则？
###  12-15 学以致用——运用关键字解决问题

## 第13章 深入浅出并发编程底层原理-下篇

  易学难精的并发编程，就像一门艺术，其实掌握了诀窍和命门，才能立于不败之地。想必小伙伴们只以为volatile只是一个关键字，殊不知，它在并发编程领域中大有可为，就连单例模式因它也变得不一般。

###  13-1 神兵利器——volatile关键字概览
###  13-2 没有银弹——volatile不适用于a++
###  13-3 雷厉风行——volatile适用场合之一：纯赋值操作
###  13-4 一触即发——volatile适用场合之二：触发器
###  13-5 能者多劳——volatile的两点作用；和synchronized的关系；volatile的总结
###  13-6 温故知新——可见性对synchronized的升华、能保证可见性的措施、可见性总结
###  13-7 密不可分——什么是原子性？
###  13-8 无需多虑——long和double的原子性、原子操作的组合不具备原子性
###  13-9 独一无二——单例模式与JMM的联系
###  13-10 车到山前——懒汉式的3种写法
###  13-11 万无一失——JMM的典型应用
###  13-12 最佳实践——静态内部类写法、枚举写法
###  13-13 一争高下——哪种实现方案最好？单例模式总结
###  13-14 正中下怀——常见面试问题
###  13-15 整章总结——Java内存模型重点回顾
###  13-16 思维导图——Java内存模型梳理，资料下载地址

## 第14章 并发死锁问题与企业级解决方案

  本章从活跃性问题入手，重点讲解了活跃性问题中最重要的死锁部分。最开始，我们为了让小伙伴们理解死锁的概念，先给出了一个必然死锁的例子，然后引出了死锁的四个必要条件，之后我们针对这四个必要条件，给出了3种解决策略，而其中哲学家刀叉问题是解决策略中最经典的问题。然后我们让理论结合实际，讲解了在实际工作中如...

###  14-1 至死方休——死锁问题概览
###  14-2 切瑳琢磨——考考你
###  14-3 一图千言——什么是死锁？
###  14-4 墨菲定律——死锁发生几率不高，但危害大
###  14-5 冤家路窄——发生死锁时看程序停止的信号
###  14-6 互不相让——银行转账发生死锁
###  14-7 星罗棋布——500人同时随机转账，依然会发生死锁
###  14-8 缺一不可——逐一对比刚才的实例，分析成因
###  14-9 精准打击——jstack命令介绍
###  14-10 防患未然——ThreadMXBean工具介绍
###  14-11 统筹安排——用换序来避免转账死锁
###  14-12 思考人生——哲学家就餐问题描述
###  14-13 代码落地——哲学家就餐问题演示
###  14-14 打破僵局——解决哲学家的死锁的4种办法
###  14-15 剥夺权利——检测与恢复策略
###  14-16 海阔天空——实际工程中避免死锁的8个tips——使用tryLock
###  14-17 一心一意——实际工程中避免死锁的8个tips——part 2
###  14-18 徒劳无功——什么是活锁？
###  14-19 你推我让——活锁演示：牛郎织女没饭吃
###  14-20 难以捉摸——解决活锁：引入随机性
###  14-21 命运不公——得不到执行
###  14-22 面试问题——死锁常见面试问题总结
###  14-23 整章总结——死锁从产生到消除重点回顾
###  14-24 思维导图——死锁从产生到消除梳理，资料下载地址

## 第15章 【最终回合】思维导图助你攻克并发

  对全课的精华和重点进行提炼和总结，并把数十道高频面试题快速回顾了一遍，方便小伙伴们准备面试，最后对【并发工具全图鉴】进行了展望。

###  15-1 有的放矢——八大重点提炼
###  15-2 直击目标——Java内存模型、死锁重点总结
###  15-3 知己知彼——面试高频考点汇总
###  15-4 百尺竿头——结语

## 第16章 【赠送体验章】修炼J.U.C十八般武艺，成为并发多面手

  喜迎双旦，重磅福利来了!并发易学难精，希望小伙伴们：百尺竿头，更进一步~跟着悟空老师，升级打怪，以终为始，攻克并发难题！新课程：10米长思维导图==J.U.C的精髓==并发界的AK47~~希望小伙伴用好这把“突击枪”，所向披靡~记住新课ID:409...

###  16-1 Java并发封神之路：精通JUC
###  16-2 并发工具类纵览：建立起Java并发体系的大厦

## 第17章 【赠送体验章】CAS+AQS

  喜迎双旦，重磅福利发射!慕课网盛情邀请实力人气新生代讲师悟空，再推新课：10米长思维导图==J.U.C的精髓==并发界的AK47~~希望小伙伴用好这把“突击枪”，所向披靡~~新课ID记住：409，不要钱的导图：http://naotu.baidu.com/file/89fb28b05e3395800f9dc2d332d2b198?token=9b45e08e55281667...

###  17-1 什么是CAS
###  17-2 CAS的等价代码、使用案例
###  17-3 如何学习AQS？