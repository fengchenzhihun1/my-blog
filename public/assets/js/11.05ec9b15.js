(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{1137:function(v,_,i){"use strict";i.r(_);var l=i(0),t=Object(l.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"什么是线程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程"}},[v._v("#")]),v._v(" 什么是线程")]),v._v(" "),l("p",[l("img",{attrs:{src:i(565),alt:""}})]),v._v(" "),l("p",[l("img",{attrs:{src:i(566),alt:""}})]),v._v(" "),l("p",[l("img",{attrs:{src:i(567),alt:""}})]),v._v(" "),l("p",[l("img",{attrs:{src:i(568),alt:""}})]),v._v(" "),l("h2",{attrs:{id:"进程和线程的不同"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的不同"}},[v._v("#")]),v._v(" 进程和线程的不同")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("起源不同")]),v._v(" "),l("p",[v._v("cpu的处理速度比外设快，为了提高cpu的执行速度")]),v._v(" "),l("p",[v._v("先有进程后有线程，为了提高cpu利用率。")])]),v._v(" "),l("li",[l("p",[v._v("概念不同")]),v._v(" "),l("p",[v._v("进程是程序运行起来的独立活动，是一个实例，是系统分配资源和调度资源独立单位，线程是cpu调度的独立单位")])]),v._v(" "),l("li",[l("p",[v._v("内存共享方式")]),v._v(" "),l("p",[v._v("进程共享很难，需要一些特殊处理")])]),v._v(" "),l("li",[l("p",[v._v("拥有资源不同")]),v._v(" "),l("ul",[l("li",[v._v("共享内容包括\n"),l("ul",[l("li",[v._v("进程代码")]),v._v(" "),l("li",[v._v("进程的公园数据")]),v._v(" "),l("li",[v._v("打开的文件描述符")]),v._v(" "),l("li",[v._v("信号处理器")]),v._v(" "),l("li",[v._v("进程的当前目录")]),v._v(" "),l("li",[v._v("用户ID与进程组ID")])])]),v._v(" "),l("li",[v._v("线程独有的\n"),l("ul",[l("li",[v._v("线程id")]),v._v(" "),l("li",[v._v("寄存器组的值")]),v._v(" "),l("li",[v._v("线程的堆栈")]),v._v(" "),l("li",[v._v("错误返回码")]),v._v(" "),l("li",[v._v("线程的信号屏蔽码")])])])])]),v._v(" "),l("li",[l("p",[v._v("数量不同")])]),v._v(" "),l("li",[l("p",[v._v("开销不同")]),v._v(" "),l("ul",[l("li",[v._v("线程的创建、终止时间比进程短")]),v._v(" "),l("li",[v._v("同一进程内的线程切换时间比进程切换短")]),v._v(" "),l("li",[v._v("同一进程的各个线程间共享内存和文件资源，可以不通过内核进行通信")])])])]),v._v(" "),l("h3",{attrs:{id:"相同"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#相同"}},[v._v("#")]),v._v(" 相同")]),v._v(" "),l("p",[v._v("在状态上非常相似的")]),v._v(" "),l("h1",{attrs:{id:"多线程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[v._v("#")]),v._v(" 多线程")]),v._v(" "),l("h2",{attrs:{id:"java语言和多线程的渊源和关系"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#java语言和多线程的渊源和关系"}},[v._v("#")]),v._v(" java语言和多线程的渊源和关系")]),v._v(" "),l("ul",[l("li",[v._v("java设计之初----支持多线程")]),v._v(" "),l("li",[v._v("在后端的定位----长居前三")]),v._v(" "),l("li",[v._v("一对一映射到操作系统的内核线程")]),v._v(" "),l("li",[v._v("jvm自动启动线程\n"),l("ul",[l("li",[v._v("SignalDispatch 操作系统发来的信号分发给适当的处理程序")]),v._v(" "),l("li",[v._v("Finalizer 负责对象的finalize（）方法")]),v._v(" "),l("li",[v._v("Reference Handle 和GC引用相关的线程")]),v._v(" "),l("li",[v._v("main 主线程，用户程序的入口")])])])]),v._v(" "),l("h2",{attrs:{id:"什么是多线程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#什么是多线程"}},[v._v("#")]),v._v(" 什么是多线程")]),v._v(" "),l("p",[l("img",{attrs:{src:i(569),alt:""}})]),v._v(" "),l("p",[l("img",{attrs:{src:i(570),alt:""}})]),v._v(" "),l("p",[v._v("多线程实例：抢火车")]),v._v(" "),l("p",[v._v("资源共享的任务")]),v._v(" "),l("h2",{attrs:{id:"为什么需要多线程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要多线程"}},[v._v("#")]),v._v(" 为什么需要多线程")]),v._v(" "),l("p",[l("img",{attrs:{src:i(571),alt:""}})]),v._v(" "),l("ul",[l("li",[l("p",[v._v("便于编建模")])]),v._v(" "),l("li",[l("p",[v._v("计算机定律：阿姆达尔定律")]),v._v(" "),l("p",[l("img",{attrs:{src:i(572),alt:""}})])]),v._v(" "),l("li",[l("p",[v._v("那些场景会用到")]),v._v(" "),l("ul",[l("li",[v._v("什么时候需要新开线程\n"),l("ul",[l("li",[v._v("同事做多件不同的事")]),v._v(" "),l("li",[v._v("为了提高工作效率、处理能力")]),v._v(" "),l("li",[v._v("需要同时有很大并发量的时候")])])])])]),v._v(" "),l("li",[l("p",[v._v("局限")]),v._v(" "),l("ul",[l("li",[v._v("性能问题：上下文切换带来的消耗")]),v._v(" "),l("li",[v._v("异构化任务（任务结构不一样）")]),v._v(" "),l("li",[v._v("线程安全：死锁、线程饥饿")])])])]),v._v(" "),l("h2",{attrs:{id:"串行、并性、并发"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#串行、并性、并发"}},[v._v("#")]),v._v(" 串行、并性、并发")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("串行和并行")]),v._v(" "),l("p",[l("img",{attrs:{src:i(573),alt:""}})])]),v._v(" "),l("li",[l("p",[v._v("并发和并行")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("并发")]),v._v(" "),l("p",[l("img",{attrs:{src:i(574),alt:""}})]),v._v(" "),l("p",[l("img",{attrs:{src:i(575),alt:""}})])]),v._v(" "),l("li",[l("p",[v._v("并行")]),v._v(" "),l("p",[l("img",{attrs:{src:i(576),alt:""}})])])])]),v._v(" "),l("li",[l("p",[v._v("是什么让并发和并行成为可能")]),v._v(" "),l("ul",[l("li",[v._v("cpu升级")]),v._v(" "),l("li",[v._v("操作系统升级")]),v._v(" "),l("li",[v._v("编程语言升级")])]),v._v(" "),l("h2",{attrs:{id:"高并发"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#高并发"}},[v._v("#")]),v._v(" 高并发")]),v._v(" "),l("h2",{attrs:{id:"什么是高并发"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#什么是高并发"}},[v._v("#")]),v._v(" 什么是高并发")]),v._v(" "),l("h2",{attrs:{id:"高并发和多线程的联系和不同"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#高并发和多线程的联系和不同"}},[v._v("#")]),v._v(" 高并发和多线程的联系和不同")]),v._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[v._v("  一种解决方案\n")])])]),l("h2",{attrs:{id:"高并发有哪些指标"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#高并发有哪些指标"}},[v._v("#")]),v._v(" 高并发有哪些指标")]),v._v(" "),l("p",[l("img",{attrs:{src:i(577),alt:""}})])])]),v._v(" "),l("p",[v._v("并发连接数")]),v._v(" "),l("p",[v._v("服务器平均请求等待时间")]),v._v(" "),l("p",[l("img",{attrs:{src:i(578),alt:""}})]),v._v(" "),l("p",[l("img",{attrs:{src:i(579),alt:""}})]),v._v(" "),l("p",[l("img",{attrs:{src:i(580),alt:""}}),l("img",{attrs:{src:i(581),alt:""}})]),v._v(" "),l("p",[v._v("同步阻塞")]),v._v(" "),l("p",[v._v("同步非阻塞")]),v._v(" "),l("p",[v._v("异步阻塞")]),v._v(" "),l("p",[v._v("异步非阻塞")]),v._v(" "),l("p",[l("a",{attrs:{href:"http://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd?token=11150672c00909cb",target:"_blank",rel:"noopener noreferrer"}},[v._v("知识图谱"),l("OutboundLink")],1)]),v._v(" "),l("h2",{attrs:{id:"synchronized"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#synchronized"}},[v._v("#")]),v._v(" Synchronized")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("对象锁")]),v._v(" "),l("ul",[l("li",[v._v("方法锁 默认锁对象为this当前实例对象")]),v._v(" "),l("li",[v._v("同步代码块锁 自己制定锁对象")])])]),v._v(" "),l("li",[l("p",[v._v("类锁")]),v._v(" "),l("p",[v._v("本质上类锁不过是Class对象的锁而已")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("由synchronized修飾的静态方法")]),v._v(" "),l("p",[v._v("类似全局锁")])]),v._v(" "),l("li",[l("p",[v._v("指定锁为class的class对象")])])])])]),v._v(" "),l("h2",{attrs:{id:"多线程访问同步方法的七种情况"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#多线程访问同步方法的七种情况"}},[v._v("#")]),v._v(" 多线程访问同步方法的七种情况")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("两个线程同时访问一个对象的同步方法")]),v._v(" "),l("p",[v._v("干扰，相互干扰")])]),v._v(" "),l("li",[l("p",[v._v("两个线程访问的是两个对象的同步方法")]),v._v(" "),l("p",[v._v("不干扰")])]),v._v(" "),l("li",[l("p",[v._v("两个线程访问的是synchronized的静态方法")]),v._v(" "),l("p",[v._v("干扰")])]),v._v(" "),l("li",[l("p",[v._v("同时访问同步方法与非同步方法")]),v._v(" "),l("p",[v._v("非同步方法不受影响")])]),v._v(" "),l("li",[l("p",[v._v("访问同一个对象的不同普通同步方法")]),v._v(" "),l("p",[v._v("同一个对象，同一个锁，同步")])]),v._v(" "),l("li",[l("p",[v._v("同时访问静态synchronized和非静态synchronized方法")]),v._v(" "),l("p",[v._v("不会  一个是this 一个是class")])]),v._v(" "),l("li",[l("p",[v._v("方法跑出异常后，会释放锁")]),v._v(" "),l("p",[v._v("lock（不会） synchroized（会释放）")])])]),v._v(" "),l("p",[l("img",{attrs:{src:i(582),alt:""}})]),v._v(" "),l("h2",{attrs:{id:"synchronized性质"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#synchronized性质"}},[v._v("#")]),v._v(" synchronized性质")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("可重入（递归锁）")]),v._v(" "),l("p",[v._v("同一线程的外层函数获取锁之后，内层函数可以直接再次获取该锁")]),v._v(" "),l("p",[v._v("避免死锁、提升封装性")]),v._v(" "),l("p",[v._v("粒度：线程而非粒度")]),v._v(" "),l("ul",[l("li",[v._v("同一个方法是可重入")]),v._v(" "),l("li",[v._v("不要求同一个方法")]),v._v(" "),l("li",[v._v("不要求同一个类")])])]),v._v(" "),l("li",[l("p",[v._v("不可中断")])]),v._v(" "),l("li",[l("p",[v._v("缺陷")]),v._v(" "),l("p",[v._v("效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程")]),v._v(" "),l("p",[v._v("不够灵活：加锁和释放的时机单一，每个锁仅有单一的条件")]),v._v(" "),l("p",[v._v("无法知道是否成功获取到锁")])])]),v._v(" "),l("h2",{attrs:{id:"原理"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[v._v("#")]),v._v(" 原理")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("枷锁和释放锁的原理： 现象、时机、深入jvm看字节码")]),v._v(" "),l("p",[v._v("内置锁")])]),v._v(" "),l("li",[l("p",[v._v("可重入原理：加锁次数计时器")])]),v._v(" "),l("li",[l("p",[v._v("保证可见性原理：内存模型")])])]),v._v(" "),l("h2",{attrs:{id:"常见面试题"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#常见面试题"}},[v._v("#")]),v._v(" 常见面试题")]),v._v(" "),l("ol",[l("li",[v._v("锁不能为空、作用域不易过大。避免死锁")]),v._v(" "),l("li",[v._v("如何选择lock与synchronized\n"),l("ul",[l("li",[v._v("尽量使用juc")]),v._v(" "),l("li",[v._v("尽量使用sychronized，可以少编写代码")])])])]),v._v(" "),l("h2",{attrs:{id:"思考题"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#思考题"}},[v._v("#")]),v._v(" 思考题")]),v._v(" "),l("ul",[l("li")]),v._v(" "),l("h2",{attrs:{id:"线程8大核心基础知识"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程8大核心基础知识"}},[v._v("#")]),v._v(" 线程8大核心基础知识")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("基础知识的重要性")]),v._v(" "),l("ul",[l("li")])]),v._v(" "),l("li",[l("p",[v._v("纵览全貌-思维导图")])]),v._v(" "),l("li",[l("p",[v._v("知识架构")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("实现多线程的方式")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("实现Runnable（更好）")])]),v._v(" "),l("li",[l("p",[v._v("继承Thread类")]),v._v(" "),l("p",[v._v("缺点")]),v._v(" "),l("ul",[l("li",[v._v("不解耦")]),v._v(" "),l("li",[v._v("只能新建独立线程（耗费性能）")]),v._v(" "),l("li",[v._v("限制可扩展性")])])]),v._v(" "),l("li",[l("p",[v._v("本质")]),v._v(" "),l("ul",[l("li",[v._v("方法一：最终调用target.run\n"),l("ul",[l("li",[v._v("使用的是thread类的run方法")])])])])])])]),v._v(" "),l("li",[l("p",[v._v("方法二：run整个被重写\n* 使用的是我们重写后的run方法")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("同时使用两种方法会怎样")]),v._v(" "),l("p",[v._v("执行thread")])]),v._v(" "),l("li",[l("p",[v._v("面试")])])])]),v._v(" "),l("li",[l("p",[v._v("oracle说的有两种")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("准确的说创建线程只有一种方式就是构造Threa类，而实现线程的执行单元有两种")])]),v._v(" "),l("li",[l("p",[v._v("错误观点")])])])]),v._v(" "),l("li",[l("p",[v._v("线程池属于创建线程的一种方式")]),v._v(" "),l("ul",[l("li",[v._v("无返回值是runnabel")])])]),v._v(" "),l("li")])]),v._v(" "),l("li",[l("p",[v._v("学习编程的优质路径")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("宏观上")]),v._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[v._v("* 并不是靠工作年限，有的人工作了五年技术却还是只懂皮毛\n* 要有强大的责任心，不放过任务bug，找到原因并去解决\n")])])]),l("ul",[l("li",[l("p",[v._v("主动：永远不会觉得自己的时间多于，重构、优化、学习、总结")]),v._v(" "),l("ul",[l("li",[v._v("敢于承担：虽然这个技术没碰到过，但是移动的调研后，敢于承担技术难题")])])]),v._v(" "),l("li",[l("p",[v._v("关心产品，关系业务")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("微观上")]),v._v(" "),l("ul",[l("li",[v._v("看经典书籍（比如java并发编程实战、自顶向下计算机网络）")]),v._v(" "),l("li",[v._v("看官方文档")])])])])]),v._v(" "),l("li",[l("p",[v._v("英文google和stackoverflow")]),v._v(" "),l("ul",[l("li",[v._v("自己动手写，实践写demo尝试用到项目里")])])]),v._v(" "),l("li",[l("p",[v._v("不理解的参考领域的多个书本，综合判断")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("如何了解技术领域的最新动态")]),v._v(" "),l("ul",[l("li",[v._v("高质量固定途径 掘金")])])])])]),v._v(" "),l("li",[l("p",[v._v("订阅技术论坛 infoq")])])])]),v._v(" "),l("li",[l("p",[v._v("如何在业务开发中成长")]),v._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[v._v("* 偏业务方向\n")])])]),l("ul",[l("li",[l("p",[v._v("核心模型")]),v._v(" "),l("ul",[l("li",[v._v("复杂的业务抽象化")])])]),v._v(" "),l("li",[l("p",[v._v("进行思考，业务扩展等")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("偏技术方法")])]),v._v(" "),l("li",[l("p",[v._v("两个25%")])])])])])])])]),v._v(" "),l("li",[l("p",[v._v("启动线程的正确和错误方式")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("start和run的比较")]),v._v(" "),l("p",[v._v("run是在主线程中而不是新建一个线程")])]),v._v(" "),l("li",[l("p",[v._v("start方法原理")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("含义")]),v._v(" "),l("p",[v._v("启动新线程（由主线程或父线程调用之后才创建新的线程）")]),v._v(" "),l("p",[v._v("start的准备工作")]),v._v(" "),l("ol",[l("li",[v._v("就绪准备（获取了除cpu以外的其他资源）")])])])])])])])]),v._v(" "),l("ol",{attrs:{start:"2"}},[l("li",[l("p",[v._v("等待获取cpu资源\n3. 不能重复调用start方法，否则会报错")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("源码解析")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("启动线程检查线程状态")])]),v._v(" "),l("li",[l("p",[v._v("加入线程组")])]),v._v(" "),l("li",[l("p",[v._v("调用start0（本地方法）")])])])]),v._v(" "),l("li",[l("p",[v._v("深入JDK源码")])]),v._v(" "),l("li",[l("p",[v._v("run方法原理")]),v._v(" "),l("ul",[l("li",[v._v("实现runable")])])])])])]),v._v(" "),l("ul",[l("li",[l("p",[v._v("重写run方法")])]),v._v(" "),l("li",[l("p",[v._v("停止线程的方法")])]),v._v(" "),l("li",[l("p",[v._v("原因")]),v._v(" "),l("ul",[l("li",[v._v("使用interrupt来通知，而不是强制")])])]),v._v(" "),l("li",[l("p",[v._v("如何正确停止")]),v._v(" "),l("ul",[l("li",[v._v("通常线程会在什么情况下停止\n"),l("ul",[l("li",[v._v("run方法正常结束")]),v._v(" "),l("li",[v._v("出现异常未捕获")])])]),v._v(" "),l("li",[v._v("正确的停止方法：interrupt\n"),l("ul",[l("li",[v._v("通常线程会在什么情况下停止普通情况")]),v._v(" "),l("li",[v._v("线程可能被阻塞")]),v._v(" "),l("li",[v._v("如果线程在每次迭代后都阻塞")]),v._v(" "),l("li",[v._v("实际开发中的两种最佳实践\n"),l("ul",[l("li",[v._v("优先选择：传递中断")]),v._v(" "),l("li",[v._v("不想或无法传递：恢复中断")]),v._v(" "),l("li",[v._v("不赢屏蔽中断")]),v._v(" "),l("li")])])])]),v._v(" "),l("li",[v._v("正确停止带来的好处")])])]),v._v(" "),l("li",[l("p",[v._v("错误方法")])]),v._v(" "),l("li",[l("p",[v._v("重要函数解析")])]),v._v(" "),l("li",[l("p",[v._v("常见面试问题")])]),v._v(" "),l("li",[l("p",[v._v("线程的6个状态")])]),v._v(" "),l("li",[l("p",[v._v("面试题")]),v._v(" "),l("ul",[l("li",[v._v("一个线程两次调用start方法会出现什么情况？为什么？")]),v._v(" "),l("li",[v._v("既然·start方法会调用run方法，为什么我们选择调用start方法，而不是调用run方法？")])])]),v._v(" "),l("li",[l("p",[v._v("Thread和Object和线程相关的方法")])]),v._v(" "),l("li",[l("p",[v._v("线程各属性")])]),v._v(" "),l("li",[l("p",[v._v("线程的未铺货异常UncaughtException应该如何处理")])]),v._v(" "),l("li",[l("p",[v._v("线程是把双刃剑：多线程会导致性能问题（线程引入的开销、上线文切换）")])]),v._v(" "),l("li",[l("p",[v._v("常见面试题")])]),v._v(" "),l("li")]),v._v(" "),l("h1",{attrs:{id:"线程的一生"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程的一生"}},[v._v("#")]),v._v(" 线程的一生")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("6中状态")]),v._v(" "),l("ul",[l("li",[v._v("new\n"),l("ul",[l("li",[v._v("已创建但是未运行")])])]),v._v(" "),l("li",[v._v("runnable\n"),l("ul",[l("li",[v._v("ready")]),v._v(" "),l("li",[v._v("running")]),v._v(" "),l("li",[v._v("被拿走，也是这个状态")])])]),v._v(" "),l("li",[v._v("blocked\n"),l("ul",[l("li",[v._v("被sychronized修饰时才会走到blocked")])])]),v._v(" "),l("li",[v._v("waitting\n*")]),v._v(" "),l("li",[v._v("timed waitting")]),v._v(" "),l("li",[v._v("terminated")])])]),v._v(" "),l("li",[l("p",[v._v("每个状态是什么含义")])]),v._v(" "),l("li",[l("p",[v._v("阻塞状态是什么")])]),v._v(" "),l("li",[l("p",[v._v("常见面试问题")])])]),v._v(" "),l("h1",{attrs:{id:"中流砥柱-7个重要方法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#中流砥柱-7个重要方法"}},[v._v("#")]),v._v(" 中流砥柱 -7个重要方法")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("为什么线程通信的方法wait，notify和notifyAll被定义在Object，sleep定义在Thread类里")])]),v._v(" "),l("li",[l("p",[v._v("用3种方式实现生产者模式")])]),v._v(" "),l("li",[l("p",[v._v("javase8，java1.8和jdk8是什么关系，是同一个东西吗")])]),v._v(" "),l("li",[l("p",[v._v("join和sleep和wait期间线程的状态分别是什么？为什么？")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("wait， notify，notifyAll")]),v._v(" "),l("p",[v._v("wait释放了锁")]),v._v(" "),l("p",[v._v("只释放当前monitor")]),v._v(" "),l("ul",[l("li",[v._v("阻塞阶段\n"),l("ul",[l("li",[v._v("另外一个线程调用")]),v._v(" "),l("li")])]),v._v(" "),l("li",[v._v("唤醒阶段")]),v._v(" "),l("li",[v._v("遇到中断")])])])])])]),v._v(" "),l("h1",{attrs:{id:"线程的重要属性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程的重要属性"}},[v._v("#")]),v._v(" 线程的重要属性")]),v._v(" "),l("ul",[l("li",[v._v("什么时候需要设置守护线程")]),v._v(" "),l("li",[v._v("线程各属性\n"),l("ul",[l("li",[v._v("线程ID")]),v._v(" "),l("li",[v._v("名称")]),v._v(" "),l("li",[v._v("守护线程")]),v._v(" "),l("li",[v._v("优先级")])])])])])}),[],!1,null,null,null);_.default=t.exports},565:function(v,_,i){v.exports=i.p+"assets/img/threaprocess.24d127cc.png"},566:function(v,_,i){v.exports=i.p+"assets/img/dingyi.7b174ac6.png"},567:function(v,_,i){v.exports=i.p+"assets/img/whatprocess.bb45fc62.png"},568:function(v,_,i){v.exports=i.p+"assets/img/threadConcept.ab8c27f5.png"},569:function(v,_,i){v.exports=i.p+"assets/img/manythread.077d49cf.png"},570:function(v,_,i){v.exports=i.p+"assets/img/bingfabingxing.49b3d1ec.png"},571:function(v,_,i){v.exports=i.p+"assets/img/provecpu.8a56fa3c.png"},572:function(v,_,i){v.exports=i.p+"assets/img/amudaer.78bce570.png"},573:function(v,_,i){v.exports=i.p+"assets/img/bingfa.695b9a74.png"},574:function(v,_,i){v.exports=i.p+"assets/img/bingfa2.753f3c59.png"},575:function(v,_,i){v.exports=i.p+"assets/img/bingfabingfa2.a556aa90.png"},576:function(v,_,i){v.exports=i.p+"assets/img/bingxiang.bfd276a5.png"},577:function(v,_,i){v.exports=i.p+"assets/img/Xshot-0029.979b9048.png"},578:function(v,_,i){v.exports=i.p+"assets/img/tongbyyibu.a1074215.png"},579:function(v,_,i){v.exports=i.p+"assets/img/yibvu01.f08347d3.png"},580:function(v,_,i){v.exports=i.p+"assets/img/Xshot-0032.17fcd57c.png"},581:function(v,_,i){v.exports=i.p+"assets/img/Xshot-0033.4fdb7404.png"},582:function(v,_,i){v.exports=i.p+"assets/img/20200302211911.78eabbb0.png"}}]);